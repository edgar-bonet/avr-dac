; === avr-dac.S: Turn an AVR into a 1-bit D/A converter. ===
;
; This program turns an AVR microcontroller into a 1-bit DAC. The
; desired analog level is loaded serially, like on a shift register, as
; an 8-bit unsigned integer. Then, once the LATCH input pin is asserted,
; the level is output as a pulse density modulated (PDM) waveform.
; Average waveform voltage for level n is (n/256)*Vcc. The PDM waveform
; is generated by a software delta-sigma modulator clocked at F_CPU/13
; (615 kHz for F_CPU = 8 MHz).
;
; Inputs:
;  - CLK: serial clock
;  - DAT: serial data, clocked on rising CLK, most significant bit first
;  - LATCH: latch the data, active-high unless configured otherwise
;
; Output:
;  - OUT: PDM output
;
; Timings:
;  - every input level should be held for at least 26 clock cycles
;  - DAT setup = 0
;  - DAT hold = 26 cycles
;  - last CLK to LATCH = 26 cycles
;
; For building the program, set the configuration parameters below to
; your liking, then type
;
;   avr-gcc -mmcu=... -nostdlib avr-dac.S -o avr-dac.elf
;
; Copyright (c) 2019 Edgar Bonet Orozco.
; Licensed under the terms of the MIT license.
; See file LICENSE for details.

;=======================================================================
; Configuration section.
;=======================================================================

; Input pin mapping. All input pins should share the same port.
#define INPUT_PORT  B
#define CLK_PIN     0
#define DAT_PIN     1
#define LATCH_PIN   2

; Output pin mapping.
#define OUTPUT_PORT B
#define OUT_PIN     3

; Clock prescaler selection: PRESCALER = 0 means full speed, otherwise
; the clock frequency is divided by 2^PRESCALER (max PRESCALER = 8).
; Selected clock speed should be compatible with operating voltage.
#define PRESCALER   0

; Uncomment this if you want LATCH to be active-low.
;#define LATCH_ACTIVE_LOW

;=======================================================================
; End of configuration section.
;=======================================================================

#include <avr/io.h>

; I/O ports.
#define concat2(a, b) a ## b
#define concat(a, b) concat2(a, b)
#define PIN_IN   concat(PIN,  INPUT_PORT)
#define DDR_OUT  concat(DDR,  OUTPUT_PORT)
#define PORT_OUT concat(PORT, OUTPUT_PORT)

; Register assignments.
.set delta,  16 ; requested DAC level
.set sigma,  17 ; integrated error
.set inputs, 18 ; sampled inputs
.set edge,   19 ; edge detector for CLK
.set shift,  20 ; shift register for incoming data
.set output, 21 ; output to be sent to PORT_OUT

init:

    ; Start at zero.
    clr delta
    clr sigma
    clr edge
    clr shift

    ; Set the clock speed.
#ifdef CLKPR
    ; These registers are not in use yet.
    ldi inputs, 1<<CLKPCE
    ldi output, PRESCALER
# if _SFR_IO_REG_P(CLKPR)
    out _SFR_IO_ADDR(CLKPR), inputs
    out _SFR_IO_ADDR(CLKPR), output
# else
    sts _SFR_MEM_ADDR(CLKPR), inputs
    sts _SFR_MEM_ADDR(CLKPR), output
# endif
#else
# warning "CLKPR register missing. Clock speed not set."
#endif

    ; Configure output pin as output.
    ldi output, 1<<OUT_PIN
    out _SFR_IO_ADDR(DDR_OUT), output

; In the following, timings are shown in brackets as:
;   [n]    = n cycles, or
;   [n, m] = n cycles on rising CLK, m cycles otherwise.
; Global loop timing:
;   [6]
;   [5] delta-sigma round
;   [8]
;   [5] delta-sigma round
;   [2]
loop:

    ; [1] Sample inputs
    in inputs, _SFR_IO_ADDR(PIN_IN)

    ; [2] Latch if needed.
#ifdef LATCH_ACTIVE_LOW
    sbrs inputs, LATCH_PIN
#else
    sbrc inputs, LATCH_PIN
#endif
    mov delta, shift

    ; [3] Read CLK into edge detector.
    lsl edge
    sbrc inputs, CLK_PIN
    ori edge, 0x01

    ; [5] First delta-sigma round.
    clr output
    add sigma, delta
    brcc 1f
    ori output, 1<<OUT_PIN
1:  out _SFR_IO_ADDR(PORT_OUT), output

    ; [3, 4] Detect edge on CLK.
    andi edge, 0x03
    cpi edge, 0x01
    brne delay

    ; [5, 0] On rising CLK, read data into shift register.
    lsl shift
    sbrc inputs, DAT_PIN
    ori shift, 0x01
    rjmp delayed

    ; [0, 4] Otherwise delay.
delay:
    rjmp .
    rjmp .
delayed:

    ; [5] Second delta-sigma round.
    clr output
    add sigma, delta
    brcc 1f
    ori output, 1<<OUT_PIN
1:  out _SFR_IO_ADDR(PORT_OUT), output

    ; [2] Loop back.
    rjmp loop
